##### 静态字段和静态方法

##### 静态字段

###### 静态字段

```
	在C#程序中，没有全局变量的概念，这意味着所有的成员变量只有该类的实例才能操作这些数据，这起到了“信息隐藏”的作用。但有些时候，这样做却不是个明智的选择。

	假设我们要定义一个图书类，要求该类能保存图书的数量，即每增加一本图书（定义一个实例），图书的数量应该加1。如果没有静态变量，我们需要将图书的数量保存在每本图书（实例）里，然而，这样的变量要在不同图书（实例）里重复存储，图书（实例）数量少的话，我们还能接受，如果图书（实例）数量较多的话，比如成千上万，我们无法想象这要造成多少资源（如内存、磁盘空间）的浪费，更让人无法忍受的是：因为图书（实例）的数量要保存在每本图书（实例）里，该值肯定是不同的。要使这些图书（实例）中保存的图书（实例）数量一致，我们必须在每增加一本新书（生成一个新实例）时，修改其他所有图书（实例）中保存的该值。Oh,My God!你会重新向往面向过程的程序设计方法，向往拥有全局变量的时代。但，这种局面不会出现，因为C#中为你准备好了另外一种变量类型：静态变量。它在类中类似全局变量，保存类的公共信息，所有该类的实例（对象）共享该值。
```

###### 声明方式如下

```
[访问修饰符] static 数据类型 变量名;
```

这里的访问修饰符跟类的其它成员一样，可以是public,protected,private或internal等。

###### 含义

```
1、静态字段被类的所有实例共享，所有实例都访问同一内存位置。因此，该内存位置的值被一个实例改变了，这种改变对所有的实例都可见；
2、可以使用static修饰符将字段声明为静态；
3、访问静态变量必须使用   类名.成员名。
```



##### 静态方法

```
	静态方法与静态变量一样，不属于任何特定的实例，属于类全体成员共有，由类名来调用。但要注意以下几点：
1、静态方法只能访问类的静态成员，不能访问类的非静态成员；
2、非静态方法可以访问类的静态成员，也可以访问类的非静态成员；
```



##### 可以声明为静态的类成员类型

- 数据成员（**常量**）
  - 字段
  - 类型
- 函数成员（**索引器**）
  - 方法
  - 属性
  - 构造函数
  - 运算符
  - 事件

```
注：括号中的不可以声明为静态成员！
```



##### 静态类

```
静态类与非静态类的重要区别在于静态类不能实例化，也就是说，不能使用 new 关键字创建静态类类型的变量。在声明一个类时使用static关键字，具有两个方面的意义：
首先，它防止程序员写代码来实例化该静态类；
其次，它防止在类的内部声明任何实例字段或方法。

使用静态类的优点在于，编译器能够执行检查以确保不致偶然地添加实例成员，编译器将保证不会创建此类的实例。静态类的另一个特征在于，C#编译器会自动把它标记为sealed。这个关键字将类指定为不可扩展；换言之，不能从它派生出其他类。
```

###### 特性

```
1：仅包含静态成员。
2：无法实例化。
3：是密封的。
4：不能包含实例构造函数。
```

###### 注意

```
注意事项：

(1) 不能使用 new 关键字创建静态类的实例；

(2) 仅包含静态成员；

(3) 不能被实例化；

(4) 密封的，不能被继承；

(5) 不能包含实例构造函数，但可以包含静态构造函数；
```

###### 什么情况下使用静态类

```
判断这个很简单,就是从内存的优化方面去考虑.因为静态和非静态的不同的地方,就是静态的从程序一启动就会一直占用内存,而非静态的只在使用后(实例化)后才会占用内存.但是每实例化个一个对象时又会另外占用内存. 举个例子,比如说一个数据库的连接字段(STRING).因为要经常使用到它,这时我们可以用STATIC.但是如果这时用非静态的话那就不合算了,因为每次调用到它时,又实例化一次.这样相比来说占用内存就比较大了.不划算. 像一个登录后台的方法,你只在登陆时候调用一次,就没有必要做成静态的了.那样一直驻存在内存中.在大型项目中,你如果都使用静态的那得要多少内存去支撑呀.嘿嘿 简单点,就是它经常要被调用时,就用静态的.相反则用非静态的.
```

[原文](https://blog.csdn.net/xiaojunhuaaini/article/details/84957292) 